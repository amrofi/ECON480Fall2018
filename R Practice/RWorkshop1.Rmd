---
title: 'R Workshop #1'
author: "Ryan Safner"
date: "11/27/2018"
output: 
  beamer_presentation:
    #theme: "metropolis"
    incremental: true 
    fig_caption: yes
    toc: true 
    slide_level: 3
    includes:
      in_header: ../Lectures/header.tex
    keep_tex: no 
    latex_engine: xelatex #required for Fira Sans font to render properly 

classoption: aspectratio=169
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library("tidyverse"))
```

# Data Wrangling

### Data Types

- A good time to refresh the different types of data
    1. `Numeric`
        - Called "`double`" if non-integer (i.e. has a decimal point)
        - Integer if an integer
    2. `Character`: any string of text (needs "quotes")
    3. `Factor`: a type of character or integer that signifies membership in a category (categories are called "`levels`")
        - Ordered factor if order/rank of levels matter (i.e. `1>2>3>4` or `freshman<sophomore<junior<senior`)
    4. `Logical`: binary variable with values either `TRUE` or `FALSE`
        - Not really applicable for our purposes
    4. `Date/time`: a point in time (Year, Month, Day, Hour, Min, Sec, etc)
        - Try to avoid if possible, if needed, ask me! 

### Data Wrangling: Why Wrangle? 

- **Multiple Sources of Data**: may want to merge multiple spreadsheets into one `data.frame`
- **Un-tidy Data**: data might come in a spreadsheet in a form that is not friendly to plotting, regression, etc 
- **Getting a Better Look**: a lot of data analysis happens before the plots and regressions, need to know *what data we have* and how it looks like
    - May need to rescale, transform, or create new variables
    - May want to **subset** or look at data **conditionally** for patterns, comparing groups, eliminate outliers, etc

### Data Wrangling: Why Wrangle? 

- This is all "stuff under the hood"
    - Most analysis requires this but you never see it in the final paper or figures 
- Generous researchers take raw, messy data and offer a copy of the final, cleaned, dataset along with their process of how they wrangled it

# Subsetting Data 

### Subsetting Data: Matrix Analogy

- `data.frame` is a type of `matrix`: each cell is \alert{indexed} by its `[row #, column #]`

\scriptsize 

```{r}
m<-matrix(c("a","b","c","d","e","f"),nrow=2)
m
```

\columnsbegin

\column{.3\textwidth}

\scriptsize 

\onslide<2->

- Subset a **specific row**:
```{r}
m[2,]
```

\column{.3\textwidth}

\scriptsize 

\onslide<3->

- Subset a **specific column**:
```{r}
m[,3]
```

\column{.3\textwidth}

\scriptsize 

\onslide<4->

- Subset a **specific element**:
```{r}
m[2,3]
```

\columnsend

### Subsetting Data

\begin{figure}
\includegraphics{subsetting}
\end{figure}


### Subsetting Data: Data Frames

- We can do the same thing for `data.frame`s: 

```{r}
df<-data.frame(Nums=c(1,2,3,4,5),
               Lets=c("a","b","c","d","e"))
df
```

```{r, echo=F}
df$Lets<-as.character(df$Lets)
```

### Subsetting Data: Data Frames

- Can also subset a `data.frame` by position:

\scriptsize 

\center

```{r}
df
```

\columnsbegin

\column{.3\textwidth}

\scriptsize 

\onslide<2->

- Subset a **specific row (observation)**:
```{r}
df[2,]
```

\column{.3\textwidth}

\scriptsize 

\onslide<3->

- Subset a **specific column (variable)**:
```{r}
df[,2]
```

\column{.3\textwidth}

\scriptsize 

\onslide<4->

- Subset a **specific value**:
```{r}
df[2,2]
```

\columnsend

### Subsetting Data: Data Frames II 

- The nice thing about data frames is that instead of remembering the order of columns, we have the `names` of columns

```{r}
df
names(df)
```

- We subset by variable name with the `$` sign instead of brackets! 

```{r}
df$Nums

df$Lets
```

### Subsetting Conditionally

- We often want to subset a `data.frame` based on a \alert{condition}
    - e.g. look only at **observations for which `Nums` are larger than 2**
- Can use original brackets `[]` to pick by **rows** (observations) for which `Num>2`

\columnsbegin

\column{.3\textwidth}

\scriptsize 

\onslide<4->

- If we want **all** columns (variables)
```{r}
df[df$Nums>2,]
```

\column{.3\textwidth}

\scriptsize 

\onslide<5->

- If we only want column 1 (`"Nums"`)
```{r}
df[df$Nums>2,1]
```

\column{.3\textwidth}

\scriptsize 

\onslide<6->

- If we only want column 2 (`"Lets"`)
```{r}
df[df$Nums>2,2]
```

\columnsend


### Subsetting Conditionally: `subset()`

- One faster way that gets us away from `[]` is `subset(df, condition)`
    - Keeps only values of `df` for which condition is `TRUE`

\onslide<3->
```{r}
subset(df, Nums>2)
```

### Subsetting Conditionally: `filter()` with `dplyr`

- `dplyr` makes this easier with `filter()`

```{r}
df %>%
  filter(Nums>2)
```

### Useful Conditionals 

| Condition | Description | Example(s) |
|-----------------------------|------------------------------|----------------------------|
| `>`       | Values greater than | `Num>2` | 
| `>=`      | Values greater than or equal to | `Num>=2` | 
| `==`      | Values equal to (put value in quotes if a character) | `Num==2`; `Let=="a"` | 
| `!=`      | Values are NOT equal to | `Num!=2`; `Let!="a"` |
| `cond.1 & cond.2` | "AND": BOTH conditions must be met  | `Num>2 & Num<5` | 
| `cond.1 | cond.2` | "OR": Either one condition must be met | `Num>2 | Num<5` | 
| `%in% c()`    | Values are in a set of values defined in `c()` | `Num %in% c(1,2,3)` | 
| `!%in% c()`   | Values are NOT in defined set | `Num !%in% c(1,2,3)` | 

# Dealing with Missing Data

### Missing Data: `NA`

- If any observation is missing a value of a variable, it will show up as `NA`

```{r}
x<-c(1,2,NA,4,5)
y<-c("a",NA,"c","d","e")
df<-data.frame(x,y)

df

```

### `NA`s Propagate...

- Missing data propagates and will ruin many functions you run on it 

```{r}
mean(df$x)
sd(df$x)
sum(df$x)
```

### `NA` Strategy

- Several strategies to combat `NA`s
1. If looking at one variable:
    - Keep only observations for which there are no `NA`s 
```{r}
# with base R

df1<-df[!is.na(df$x),] # drop all observations for which there is NA for x 
df1

# alternatively, with dplyr

df %>%
  filter(!is.na(x)) # keep only observations that are NOT (the !) NA's 
```

- Notice this keeps the `df$y` with a `NA`

### `NA` Strategy II

2. Drop *all* observations that have some missing value across *any* variable with `na.omit(df)`
    - Often too extreme, may end up throwing out a lot of useful data! 
    
```{r}
df2<-na.omit(df) # drop any row that has any NA value for any variable 
df2
```

### `NA` Strategy III

3. Most functions have a `NA` option built in
    - Add "`,na.rm=TRUE`" inside any function's `()` to simply *ignore* all observations with `NA`s

```{r}
mean(df$x, na.rm=TRUE)
sd(df$x, na.rm=TRUE)
sum(df$x, na.rm=TRUE)
```

# Merging Datasets

###

- `rbind()` adds observation(s)-(rows) for *all* existing variables (columns)
- `cbind()` adds variable(s)-(columns) for *all* existing observations (rows)


# Tidy Data

### Tidy Data

\begin{figure}
\includegraphics{tidydata}
\end{figure}


### Tidy Data

```{r, load-data}
library("knitr")
FOTR<-read.csv("../Data/The_Fellowship_Of_The_Ring.csv")
TTT<-read.csv("../Data/The_Two_Towers.csv")
ROTK<-read.csv("../Data/The_Return_Of_The_King.csv")
```

### Tidy Data II: Three Datasets

\columnsbegin

\column{.33\textwidth}

\tiny

```{r, echo=FALSE}
kable(FOTR)
```

\column{.33\textwidth}

\tiny

```{r, echo=FALSE}
kable(TTT)
```

\column{.33\textwidth}

\tiny

```{r, echo=FALSE}
kable(ROTK)
```

\columnsend

### Tidying

```{r}
suppressPackageStartupMessages(library("tidyverse"))
LOTR <- bind_rows(FOTR, TTT, ROTK)
```

### Tidying II

```{r}
str(LOTR)
```

### 

```{r}
LOTR
```

### Tidying III

\scriptsize 

```{r}
LOTR_tidy <-
  gather(LOTR, key = 'Gender', value = 'Words', Female, Male)
LOTR_tidy
```

### Saving the Tidy Data

```{r}
write.csv(LOTR_tidy,"../Data/LOTR_tidy.csv")
```

### Now We Can Work With This 

- Tidy data works better for analysis 
- All `tidyverse` packages assume tidy data

```{r}
LOTR_tidy %>% 
  count(Gender, Race, wt = Words)
```

###

```{r}
by_race_film <- LOTR_tidy %>% 
   group_by(Film, Race) %>% 
   summarize(Words = sum(Words))

by_race_film
```

###

```{r}
p <- ggplot(by_race_film, aes(x = Film, y = Words, fill = Race))
p + geom_bar(stat = "identity", position = "dodge") +
  coord_flip() + guides(fill = guide_legend(reverse = TRUE))
```

# Managing Your Workflow 

### Using `RProj` Projects

\begin{figure}
\includegraphics{workflowgithub.png}
\end{figure}


# Advanced: Automate All The Things!

### Automate all the Things!

- You may find yourself in one of the following positions:
    1. You have a very specific need that existing commands do not easily address
    2. You are running the same task many times on different objects
- If so, you can solve your needs with:
    1. Writing your own `R` `function`s
    2. Running a `for` loop 
- Famous acronym in computer science: **DRY: Don't Repeat Yourself**
    - increases likelihood of error
    - easier for readers to follow your intent


### `function`s in `R`

- We've seen built in functions like `mean()`
- You can write your own functions using the following syntax:

```{r, eval=F}
my.function<-function(inputs){
  argument.using.inputs
}
```

### `function`s in `R` II 

- Let's make our own `mean()` function called `my.mean()`: 

```{r}
my.mean<-function(x){
  sum(x)/length(x)
}
```

### `function`s in `R` III 

- You can then use your function on any object 

```{r}
a<-c(1,2,3,4,5)

my.mean(a)

b<-c(2,4,6,8,10)

my.mean(b)
```

### Another Simple Example

- You can even put another function as an input to a function

```{r}
power<-function(exponent){
  function(x) x^exponent
}

# define other functions 
square<-power(2)
cube<-power(3)

# run on examples

square(6)
cube(2)
```

### `for` Loops

- `R` will execute some statement `for` each `value` in a `sequence` of values:

```{r, eval=F}
for (value in sequence){
  statement
}
```

### `for `Loops 

- Square all the numbers in the following vector `numbers.to.square` 

```{r}
numbers.to.square<-c(1,7.5,pi,3,-57,874,91)

for (i in numbers.to.square){
  print(i^2)
}
```
